<body>

A Java object-model for a Java Bytecode Macro-Assembler.

<h2>Description</h2>

<p>
The ByteCode package is able to generate Java Bytecode that can be used to
define Java classes. It is not restricted to things that can be expressed as
Java code (as in .java files), and is more flexible than basic Java bytecode.
</p>

<p>
This package supports generating classes, interfaces, methods, fields, and the
like. It follows the macro-assembler pattern, where users can effectively
extend the bytecode instruction set with their own instructions that at
compile time expand to real bytecode instructions. Many useful
pseudo-instructions are provided, such as IfExpression. This package also
supports some advanced functionality such as templating. Templating supports
both object and primitive types and types can be resolved at the level of
complete methods or single expressions.
</p>

<p>
The ByteCode package has no support whatsoever for editing Java Bytecode. In
particular, there is no support for search-and-replace or optimization.
</p>

<p>
The main classes for generating bytecode are
{@link org.biojava.utils.bytecode.CodeUtils},
{@link org.biojava.utils.bytecode.ByteCode},
{@link org.biojava.utils.bytecode.InstructionVector} and
{@link org.biojava.utils.bytecode.GeneratedCodeClass}. You will probably also
use {@link org.biojava.utils.bytecode.GeneratedClassLoader}, as it does the
actual work of building and loading classes.
</p>

<p>
It is probably a requirement of using this package effectively that you have
memorised or have handy a copy of the Java VM specification. This is available
from the Sun web site.
</p>

<h2>Class Reflection</h2>

<p>
The ByteCode package represents classes, methods and fields using its own APIs.
These, for obvious reasons, closely resemble those provided by the core Java
APIs. The three interfaces
{@link org.biojava.utils.bytecode.CodeClass},
{@link org.biojava.utils.bytecode.CodeMethod} and
{@link org.biojava.utils.bytecode.CodeField}
represent these basic concepts.
</p>

<p>
Classes from the Java VM are reflected into this model using
{@link org.biojava.utils.bytecode.IntrospectedCodeClass}.
To get an instance, use the factory method
{@link org.biojava.utils.bytecode.IntrospectedCodeClass#forClass(Class)} or
{@link org.biojava.utils.bytecode.IntrospectedCodeClass#forClass(String)}.
</p>

<h2>Class Generation</h2>

<p>
Classes that you generate yourself will be represented by instances of
{@link org.biojava.utils.bytecode.GeneratedCodeClass}.
Methods are created by calling
{@link org.biojava.utils.bytecode.GeneratedCodeClass#createMethod},
which will return a
{@link org.biojava.utils.bytecode.GeneratedCodeMethod}. The method can then be
implemented by associating a
{@link org.biojava.utils.bytecode.CodeGenerator}
with the method on that particular class using
{@link org.biojava.utils.bytecode.GeneratedCodeClass#setCodeGenerator}.
</p>

<p>
Fields are generated by calling
{@link org.biojava.utils.bytecode.GeneratedCodeClass#createField}.
</p>

<p>
The classes themselves are instantiated into the VM using
{@link org.biojava.utils.bytecode.GeneratedClassLoader}.
This implements
{@link java.lang.ClassLoader#defineClass} and
over-rides the other necessary book-keeping methods. You may wish to sub-class
or wrap this class in an application to generate the desired behavior.
</p>

<h2>An example</h2>

<p>
We are going to implement HelloWorld in bytecode. Here is the (annotated) code.
</p>

<p>
Firstly, lets define our application structure...
<code><pre>
public class BCHelloWorld {
  public static void main(String[] args)
  throws Throwable {
    createHelloWorld().run();
  }

  public static Runnable createHelloWorld() {
    ...
  }
}
</pre>
</code>
We will fill in the createHelloWorld method to actualy do the work of printing
out hello world by implementing a Runnable with a run() method. Firstly, we
need a load of types, methods and a field or two.
<code>
<pre>
CodeClass cl_Object = IntrospectedCodeClass.forClass(Object.class);
CodeClass cl_String = IntrospectedCodeClass.forClass(String.class);
CodeClass cl_System = IntrospectedCodeClass.forClass(System.class);
CodeClass cl_PrintStream = IntrospectedCodeClass.forClass(PrintStream.class);
CodeClass cl_Void = IntrospectedCodeClass.forClass(Void.TYPE);
CodeClass cl_Runnable = IntrospectedCodeClass.forClass(Runnable.class);

CodeField f_System_out = cl_System.getFieldByName("out");

CodeMethod m_PrintStream_printLn = cl_PrintStream.getMethod(
    "printLn",
    new CodeClass[] { cl_String } );
CodeMethod m_Object_init = cl_Object.getConstructor(CodeUtils.EMPTY_LIST);
</pre>
</code>
Now we are ready to create our code class. It will be called HelloWorldRunnable,
inherit directly from Object, implement Runnable, and be a public class.
<code>
<pre>
GeneratedCodeClass ourClass = new GeneratedCodeClass(
    "HelloWorldRunnable",
    cl_Object,
    new CodeClass[] { cl_Runnable },
    CodeUtils.ACC_PUBLIC | CodeUtils.ACC_SUPER);
</pre>
</code>
This will need a constructor. Remember, constructors have the name &gt;init&lt:,
and you must be sure to call the super-constructor explicitly. Normaly the javac
compiler does this for you.
<code>
<pre>
GeneratedCodeMethod init = ourClass.createMethod(
    "&lt;init&gt;",
    cl_Void,
    CodeUtils.EMPTY_LIST,
    CodeUtils.ACC_PUBLIC);
InstructionVector initIV = new InstructionVector();
initIV.add(ByteCode.make_aload(init.getThis()));
initIV.add(ByteCode.make_invokespecial(m_Object_init));
initIV.add(ByteCode.make_return());
ourClass.setCodeGenerator(init, initIV);
</pre>
</code>
To be a Runnable implementation, we must also provide a run() method. This will
take no arguments, return void and be publically accessible. Also, the body of
this method will print out "Hello World" and then we can all feel pleased with
ourselves.
<code>
<pre>
GeneratedCodeMethod run = ourClass.createMethod(
    "run",
    cl_Void,
    CodeUtils.EMPTY_LIST,
    CodeUtils.ACC_PUBLIC);
InstructionVector runIV = new InstructionVector();
runIV.add(ByteCode.make_getstatic(f_System_out));
runIV.add(ByteCode.make_sconst("Hello World");
runIV.add(ByteCode.make_invokevirtual(m_PrintStream_printLn));
runIV.add(ByteCode.make_return());
ourClass.setCodeGenerator(run, runIV);
</pre>
</code>
Now we want to load in a class with this deffinition and instantiate it.
<code>
<pre>
GeneratedClassLoader gcl = new GeneratedClassLoader(class.getClassLoader());
Class newClass = gcl.defineClass(ourClass);
return (Runnable) newClass.newInstance();
</pre>
</code>
And there you are. With any luck, if you type all of this in, and the fates
smile on you, and biojava.jar is arround for linking against, you should have
generated your very own unuque HelloWorld class.
</p>

<p>
Good luck.
</p>

</body>
